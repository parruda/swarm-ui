#!/usr/bin/env ruby
# frozen_string_literal: true

require "base64"
require "json"
require "shellwords"
require "fileutils"
require "time"

# Get the base64 encoded argument
encoded_arg = ARGV.join("")

# Decode and parse JSON with symbol keys
decoded = Base64.urlsafe_decode64(encoded_arg)
params = JSON.parse(decoded, symbolize_names: true)

# Extract parameters
tmux_session_name = params[:tmux_session_name]
project_path = params[:project_path]
swarm_file = params[:swarm_file]
use_worktree = params[:use_worktree]
session_id = params[:session_id]
new_session = params[:new_session]
openai_api_key = params[:openai_api_key]
environment_variables = params[:environment_variables]
initial_prompt = params[:initial_prompt]

# Build the command
if new_session
  command = "bundle exec claude-swarm start #{swarm_file}"
  command += " --session-id #{session_id}"
  command += " --worktree" if use_worktree
  command += " --root-dir #{project_path}"
  command += " -i #{Shellwords.escape(initial_prompt)}" if initial_prompt && !initial_prompt.empty?
else
  command = "bundle exec claude-swarm restore #{session_id}"
end

rails_root = File.expand_path("..", __dir__)
status_script = File.join(rails_root, "bin", "update_session_status")
log_file = File.join(rails_root, "tmp", "tmux-bg.log")

# Ensure tmp directory exists
FileUtils.mkdir_p(File.dirname(log_file))

# Mark session as active before starting
system(status_script, session_id, "active")

# Build environment for tmux session
env = {}
env["OPENAI_API_KEY"] = openai_api_key if openai_api_key && !openai_api_key.empty?
env["SWARM_SESSION_ID"] = session_id

# Parse and add custom environment variables
if environment_variables && !environment_variables.empty?
  case environment_variables
  when Hash
    # Handle Hash format (from database)
    environment_variables.each do |key, value|
      env[key.to_s] = value.to_s
    end
  when String
    # Handle String format (legacy)
    environment_variables.each_line do |line|
      line = line.strip
      next if line.empty? || line.start_with?("#")

      key, value = line.split("=", 2)
      if key && value
        env[key.strip] = value.strip
      end
    end
  end
end

# Log to file and console
def log_message(log_file, message)
  timestamp = Time.now.strftime("%Y-%m-%d %H:%M:%S")
  log_entry = "[#{timestamp}] #{message}"

  puts message
  File.open(log_file, "a") do |f|
    f.puts log_entry
  end
end

log_message(log_file, "=" * 60)
log_message(log_file, "Starting background session: #{session_id}")
log_message(log_file, "Tmux session: #{tmux_session_name}")
log_message(log_file, "Working directory: #{project_path}")
log_message(log_file, "Swarm file: #{swarm_file}")
log_message(log_file, "Command: #{command}")

# Create a wrapper command that logs failures
wrapper_command = <<~BASH
  #{command} || echo "Environment:\n$(env)" && read -p "Press Enter to continue..." && ({
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] Claude-swarm command failed with exit code: $?" >> #{log_file}
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] Session ID: #{session_id}" >> #{log_file}
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] ENV: #{env.inspect}" >> #{log_file}
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] Command was: #{command}" >> #{log_file}
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] Working directory: $(pwd)" >> #{log_file}
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] ========================================" >> #{log_file}
    exit $?
  })
BASH

# Start tmux session in detached mode with the wrapper command
success = system(env, "tmux", "-f", "config/tmux.conf", "new-session", "-d", "-s", tmux_session_name, "bash", "-c", wrapper_command)

if success
  log_message(log_file, "Background session started successfully")
else
  log_message(log_file, "Failed to start tmux session")
  log_message(log_file, "=" * 60)
  exit 1
end

# NOTE: We cannot mark as stopped here because tmux -d returns immediately
# The session will remain active until manually stopped or claude-swarm exits
